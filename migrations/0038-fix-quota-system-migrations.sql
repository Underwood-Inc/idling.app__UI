-- Migration: Fix Failed Quota System Migrations
-- Description: Resolves foreign key constraint issues in migrations 0026 and 0027
-- Author: System
-- Date: 2025-01-29

-- ================================
-- FIX MIGRATION 0026: Custom Alerts System
-- ================================

-- First, ensure we have the custom_alerts table structure
CREATE TABLE IF NOT EXISTS CUSTOM_ALERTS (
    ID SERIAL PRIMARY KEY,
 
    -- Alert identification
    TITLE VARCHAR(200) NOT NULL,
    MESSAGE TEXT,
    DETAILS TEXT,
    ALERT_TYPE VARCHAR(50) NOT NULL DEFAULT 'info',
 
    -- Targeting and scheduling
    TARGET_AUDIENCE VARCHAR(50) NOT NULL DEFAULT 'all',
    TARGET_ROLES JSONB,
    TARGET_USERS JSONB,
 
    -- Display configuration
    PRIORITY INTEGER DEFAULT 0,
    ICON VARCHAR(20),
    DISMISSIBLE BOOLEAN DEFAULT TRUE,
    PERSISTENT BOOLEAN DEFAULT FALSE,
 
    -- Scheduling
    START_DATE TIMESTAMP WITH TIME ZONE,
    END_DATE TIMESTAMP WITH TIME ZONE,
    EXPIRES_AT TIMESTAMP WITH TIME ZONE,
 
    -- Status and metadata
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    IS_PUBLISHED BOOLEAN DEFAULT FALSE,
    CREATED_BY INTEGER REFERENCES USERS(ID),
    UPDATED_BY INTEGER REFERENCES USERS(ID),
    CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UPDATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 
    -- Additional configuration
    ACTIONS JSONB,
    METADATA JSONB,
 
    -- Constraints
    CHECK (ALERT_TYPE IN ('info', 'warning', 'error', 'success', 'maintenance', 'custom')),
    CHECK (TARGET_AUDIENCE IN ('all', 'authenticated', 'subscribers', 'admins', 'role_based', 'specific_users')),
    CHECK (PRIORITY >= -100 AND PRIORITY <= 100),
    CHECK (START_DATE IS NULL OR END_DATE IS NULL OR START_DATE <= END_DATE)
);

-- Create alert dismissals table
CREATE TABLE IF NOT EXISTS ALERT_DISMISSALS (
    ID SERIAL PRIMARY KEY,
    ALERT_ID INTEGER NOT NULL REFERENCES CUSTOM_ALERTS(ID) ON DELETE CASCADE,
    USER_ID INTEGER NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE,
    DISMISSED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(ALERT_ID, USER_ID)
);

-- Create alert analytics table
CREATE TABLE IF NOT EXISTS ALERT_ANALYTICS (
    ID SERIAL PRIMARY KEY,
    ALERT_ID INTEGER NOT NULL REFERENCES CUSTOM_ALERTS(ID) ON DELETE CASCADE,
    TOTAL_VIEWS INTEGER DEFAULT 0,
    TOTAL_DISMISSALS INTEGER DEFAULT 0,
    UNIQUE_VIEWERS INTEGER DEFAULT 0,
    CLICK_THROUGH_RATE DECIMAL(5, 4) DEFAULT 0,
    DATE DATE NOT NULL DEFAULT CURRENT_DATE,
    UNIQUE(ALERT_ID, DATE)
);

-- ================================
-- FIX MIGRATION 0027: Global Guest Quotas
-- ================================

-- Create global guest quotas table
CREATE TABLE IF NOT EXISTS GLOBAL_GUEST_QUOTAS (
    ID SERIAL PRIMARY KEY,
    SERVICE_NAME VARCHAR(50) NOT NULL,
    FEATURE_NAME VARCHAR(100) NOT NULL,
 
    -- Quota configuration
    QUOTA_LIMIT INTEGER NOT NULL DEFAULT 1,
    IS_UNLIMITED BOOLEAN DEFAULT FALSE,
 
    -- Time window configuration
    RESET_PERIOD VARCHAR(20) NOT NULL DEFAULT 'daily' CHECK (RESET_PERIOD IN ('hourly', 'daily', 'weekly', 'monthly')),
 
    -- Admin configuration
    IS_ACTIVE BOOLEAN DEFAULT TRUE,
    CREATED_BY INTEGER REFERENCES USERS(ID),
 
    -- Metadata
    DESCRIPTION TEXT,
    CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UPDATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 
    -- Constraints
    UNIQUE(SERVICE_NAME, FEATURE_NAME),
    CHECK (QUOTA_LIMIT >= 0 OR IS_UNLIMITED = TRUE),
 
    -- Foreign key constraint to ensure service/feature exists
    FOREIGN KEY (SERVICE_NAME) REFERENCES SUBSCRIPTION_SERVICES(NAME) ON DELETE CASCADE
);

-- Create guest usage tracking table
CREATE TABLE IF NOT EXISTS GUEST_USAGE_TRACKING (
    ID SERIAL PRIMARY KEY,
 
    -- Guest identification
    CLIENT_IP VARCHAR(45) NOT NULL,
    MACHINE_FINGERPRINT VARCHAR(32),
    USER_AGENT_HASH VARCHAR(64),
 
    -- Service/feature tracking
    SERVICE_NAME VARCHAR(50) NOT NULL,
    FEATURE_NAME VARCHAR(100) NOT NULL,
 
    -- Usage data
    USAGE_DATE DATE NOT NULL DEFAULT CURRENT_DATE,
    USAGE_COUNT INTEGER NOT NULL DEFAULT 1,
 
    -- Context metadata
    METADATA JSONB,
 
    -- Timestamps
    CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UPDATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 
    -- Constraints
    UNIQUE(CLIENT_IP, MACHINE_FINGERPRINT, SERVICE_NAME, FEATURE_NAME, USAGE_DATE),
    CHECK (USAGE_COUNT >= 0),
 
    -- Foreign key constraint
    FOREIGN KEY (SERVICE_NAME) REFERENCES SUBSCRIPTION_SERVICES(NAME) ON DELETE CASCADE
);

-- Create user quota overrides table
CREATE TABLE IF NOT EXISTS USER_QUOTA_OVERRIDES (
    ID SERIAL PRIMARY KEY,
    USER_ID INTEGER NOT NULL REFERENCES USERS(ID) ON DELETE CASCADE,
    SERVICE_NAME VARCHAR(50) NOT NULL,
    FEATURE_NAME VARCHAR(100) NOT NULL,
 
    -- Override configuration
    QUOTA_LIMIT INTEGER,
    IS_UNLIMITED BOOLEAN DEFAULT FALSE,
 
    -- Admin tracking
    CREATED_BY INTEGER REFERENCES USERS(ID),
    REASON TEXT,
 
    -- Metadata
    CREATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UPDATED_AT TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
 
    -- Constraints
    UNIQUE(USER_ID, SERVICE_NAME, FEATURE_NAME),
    CHECK (QUOTA_LIMIT IS NULL OR QUOTA_LIMIT >= 0 OR IS_UNLIMITED = TRUE),
 
    -- Foreign key constraint
    FOREIGN KEY (SERVICE_NAME) REFERENCES SUBSCRIPTION_SERVICES(NAME) ON DELETE CASCADE
);

-- ================================
-- CREATE INDEXES
-- ================================

-- Custom alerts indexes
CREATE INDEX IF NOT EXISTS IDX_CUSTOM_ALERTS_ACTIVE_PUBLISHED ON CUSTOM_ALERTS(IS_ACTIVE, IS_PUBLISHED) WHERE IS_ACTIVE = TRUE AND IS_PUBLISHED = TRUE;

CREATE INDEX IF NOT EXISTS IDX_CUSTOM_ALERTS_SCHEDULING ON CUSTOM_ALERTS(START_DATE, END_DATE, EXPIRES_AT) WHERE IS_PUBLISHED = TRUE;

CREATE INDEX IF NOT EXISTS IDX_CUSTOM_ALERTS_PRIORITY ON CUSTOM_ALERTS(PRIORITY DESC) WHERE IS_ACTIVE = TRUE AND IS_PUBLISHED = TRUE;

CREATE INDEX IF NOT EXISTS IDX_CUSTOM_ALERTS_TARGET_AUDIENCE ON CUSTOM_ALERTS(TARGET_AUDIENCE) WHERE IS_ACTIVE = TRUE AND IS_PUBLISHED = TRUE;

CREATE INDEX IF NOT EXISTS IDX_CUSTOM_ALERTS_CREATED_BY ON CUSTOM_ALERTS(CREATED_BY);

-- Alert dismissals indexes
CREATE INDEX IF NOT EXISTS IDX_ALERT_DISMISSALS_ALERT_ID ON ALERT_DISMISSALS(ALERT_ID);

CREATE INDEX IF NOT EXISTS IDX_ALERT_DISMISSALS_USER_ID ON ALERT_DISMISSALS(USER_ID);

-- Alert analytics indexes
CREATE INDEX IF NOT EXISTS IDX_ALERT_ANALYTICS_ALERT_ID ON ALERT_ANALYTICS(ALERT_ID);

CREATE INDEX IF NOT EXISTS IDX_ALERT_ANALYTICS_DATE ON ALERT_ANALYTICS(DATE);

-- Global guest quotas indexes
CREATE INDEX IF NOT EXISTS IDX_GLOBAL_GUEST_QUOTAS_SERVICE ON GLOBAL_GUEST_QUOTAS(SERVICE_NAME);

CREATE INDEX IF NOT EXISTS IDX_GLOBAL_GUEST_QUOTAS_FEATURE ON GLOBAL_GUEST_QUOTAS(SERVICE_NAME, FEATURE_NAME);

CREATE INDEX IF NOT EXISTS IDX_GLOBAL_GUEST_QUOTAS_ACTIVE ON GLOBAL_GUEST_QUOTAS(IS_ACTIVE) WHERE IS_ACTIVE = TRUE;

-- Guest usage tracking indexes
CREATE INDEX IF NOT EXISTS IDX_GUEST_USAGE_IP_DATE ON GUEST_USAGE_TRACKING(CLIENT_IP, USAGE_DATE);

CREATE INDEX IF NOT EXISTS IDX_GUEST_USAGE_FINGERPRINT_DATE ON GUEST_USAGE_TRACKING(MACHINE_FINGERPRINT, USAGE_DATE) WHERE MACHINE_FINGERPRINT IS NOT NULL;

CREATE INDEX IF NOT EXISTS IDX_GUEST_USAGE_SERVICE_DATE ON GUEST_USAGE_TRACKING(SERVICE_NAME, FEATURE_NAME, USAGE_DATE);

CREATE INDEX IF NOT EXISTS IDX_GUEST_USAGE_CLEANUP ON GUEST_USAGE_TRACKING(USAGE_DATE);

-- User quota overrides indexes
CREATE INDEX IF NOT EXISTS IDX_USER_QUOTA_OVERRIDES_USER ON USER_QUOTA_OVERRIDES(USER_ID);

CREATE INDEX IF NOT EXISTS IDX_USER_QUOTA_OVERRIDES_SERVICE ON USER_QUOTA_OVERRIDES(SERVICE_NAME, FEATURE_NAME);

-- ================================
-- INSERT DEFAULT GLOBAL GUEST QUOTAS (WITHOUT CREATED_BY)
-- ================================

INSERT INTO GLOBAL_GUEST_QUOTAS (
    SERVICE_NAME,
    FEATURE_NAME,
    QUOTA_LIMIT,
    RESET_PERIOD,
    DESCRIPTION
) VALUES (
    'og_generator',
    'daily_generations',
    1,
    'daily',
    'Default daily generation limit for anonymous users'
),
(
    'custom_emoji',
    'emoji_slots',
    0,
    'daily',
    'Custom emojis require user account'
),
(
    'api_access',
    'api_requests',
    100,
    'hourly',
    'API rate limit for anonymous users'
),
(
    'content_system',
    'daily_posts',
    5,
    'daily',
    'Daily content creation limit for guests'
) ON CONFLICT (
    SERVICE_NAME,
    FEATURE_NAME
) DO NOTHING;

-- ================================
-- CREATE QUOTA MANAGEMENT FUNCTIONS
-- ================================

-- Function to get effective quota for a user
CREATE OR REPLACE FUNCTION GET_EFFECTIVE_USER_QUOTA(
    P_USER_ID INTEGER,
    P_SERVICE_NAME VARCHAR(50),
    P_FEATURE_NAME VARCHAR(100)
) RETURNS TABLE( QUOTA_LIMIT INTEGER, IS_UNLIMITED BOOLEAN, SOURCE VARCHAR(20) ) AS
    $$                       DECLARE V_OVERRIDE_QUOTA INTEGER;
    V_OVERRIDE_UNLIMITED     BOOLEAN;
    V_SUBSCRIPTION_QUOTA     INTEGER;
    V_SUBSCRIPTION_UNLIMITED BOOLEAN;
BEGIN
 
    -- Check for user-specific override first
    SELECT
        UQO.QUOTA_LIMIT,
        UQO.IS_UNLIMITED INTO V_OVERRIDE_QUOTA,
        V_OVERRIDE_UNLIMITED
    FROM
        USER_QUOTA_OVERRIDES UQO
    WHERE
        UQO.USER_ID = P_USER_ID
        AND UQO.SERVICE_NAME = P_SERVICE_NAME
        AND UQO.FEATURE_NAME = P_FEATURE_NAME;
    IF FOUND THEN
        RETURN QUERY
        SELECT
            V_OVERRIDE_QUOTA,
            V_OVERRIDE_UNLIMITED,
            'override'::VARCHAR(20);
        RETURN;
    END IF;
 

    -- Fall back to subscription-based quota
    SELECT
        CASE
            WHEN PFV.FEATURE_VALUE::TEXT = '-1' THEN
                -1
            ELSE
                (PFV.FEATURE_VALUE::TEXT)::INTEGER
        END,
        PFV.FEATURE_VALUE::TEXT = '-1' INTO V_SUBSCRIPTION_QUOTA,
        V_SUBSCRIPTION_UNLIMITED
    FROM
        USER_SUBSCRIPTIONS US
        JOIN SUBSCRIPTION_PLANS SP
        ON US.PLAN_ID = SP.ID
        JOIN PLAN_FEATURE_VALUES PFV
        ON SP.ID = PFV.PLAN_ID
        JOIN SUBSCRIPTION_FEATURES SF
        ON PFV.FEATURE_ID = SF.ID
        JOIN SUBSCRIPTION_SERVICES SS
        ON SF.SERVICE_ID = SS.ID
    WHERE
        US.USER_ID = P_USER_ID
        AND US.STATUS IN ('active', 'trialing')
        AND (US.EXPIRES_AT IS NULL
        OR US.EXPIRES_AT > NOW())
        AND SS.NAME = P_SERVICE_NAME
        AND SF.NAME = P_FEATURE_NAME
    ORDER BY
        SP.SORT_ORDER DESC LIMIT 1;
    IF FOUND THEN
        RETURN QUERY
        SELECT
            V_SUBSCRIPTION_QUOTA,
            V_SUBSCRIPTION_UNLIMITED,
            'subscription'::VARCHAR(20);
        RETURN;
    END IF;
 

    -- Fall back to default subscription feature value
    SELECT
        CASE
            WHEN SF.DEFAULT_VALUE::TEXT = '-1' THEN
                -1
            ELSE
                (SF.DEFAULT_VALUE::TEXT)::INTEGER
        END,
        SF.DEFAULT_VALUE::TEXT = '-1' INTO V_SUBSCRIPTION_QUOTA,
        V_SUBSCRIPTION_UNLIMITED
    FROM
        SUBSCRIPTION_FEATURES SF
        JOIN SUBSCRIPTION_SERVICES SS
        ON SF.SERVICE_ID = SS.ID
    WHERE
        SS.NAME = P_SERVICE_NAME
        AND SF.NAME = P_FEATURE_NAME LIMIT 1;
    IF FOUND THEN
        RETURN QUERY
        SELECT
            V_SUBSCRIPTION_QUOTA,
            V_SUBSCRIPTION_UNLIMITED,
            'default'::VARCHAR(20);
        RETURN;
    END IF;
 

    -- Ultimate fallback
    RETURN QUERY SELECT 1, FALSE, 'system'::VARCHAR(20);
END;

$$ LANGUAGE PLPGSQL STABLE;
 
-- Function to get guest quota
CREATE OR REPLACE FUNCTION GET_GUEST_QUOTA( P_SERVICE_NAME VARCHAR(50), P_FEATURE_NAME VARCHAR(100) ) RETURNS TABLE( QUOTA_LIMIT INTEGER, IS_UNLIMITED BOOLEAN, RESET_PERIOD VARCHAR(20) ) AS
    $$     BEGIN RETURN QUERY
    SELECT
        GGQ.QUOTA_LIMIT,
        GGQ.IS_UNLIMITED,
        GGQ.RESET_PERIOD
    FROM
        GLOBAL_GUEST_QUOTAS GGQ
    WHERE
        GGQ.SERVICE_NAME = P_SERVICE_NAME
        AND GGQ.FEATURE_NAME = P_FEATURE_NAME
        AND GGQ.IS_ACTIVE = TRUE LIMIT 1;
 
    -- If no specific quota found, return default
    IF     NOT FOUND THEN
        RETURN QUERY
        SELECT
            1,
            FALSE,
            'daily'::VARCHAR(20);
    END IF;
END;
$$     LANGUAGE PLPGSQL STABLE;
 
-- Function to record guest usage
CREATE OR REPLACE

FUNCTION RECORD_GUEST_USAGE(
    P_CLIENT_IP VARCHAR(45),
    P_MACHINE_FINGERPRINT VARCHAR(32),
    P_USER_AGENT_HASH VARCHAR(64),
    P_SERVICE_NAME VARCHAR(50),
    P_FEATURE_NAME VARCHAR(100),
    P_USAGE_COUNT INTEGER DEFAULT 1,
    P_METADATA JSONB DEFAULT NULL
) RETURNS INTEGER AS
    $$ DECLARE V_NEW_USAGE_COUNT INTEGER;
BEGIN
    INSERT INTO GUEST_USAGE_TRACKING (
        CLIENT_IP,
        MACHINE_FINGERPRINT,
        USER_AGENT_HASH,
        SERVICE_NAME,
        FEATURE_NAME,
        USAGE_COUNT,
        METADATA
    ) VALUES (
        P_CLIENT_IP,
        P_MACHINE_FINGERPRINT,
        P_USER_AGENT_HASH,
        P_SERVICE_NAME,
        P_FEATURE_NAME,
        P_USAGE_COUNT,
        P_METADATA
    ) ON CONFLICT (
        CLIENT_IP,
        MACHINE_FINGERPRINT,
        SERVICE_NAME,
        FEATURE_NAME,
        USAGE_DATE
    ) DO UPDATE SET USAGE_COUNT = GUEST_USAGE_TRACKING.USAGE_COUNT + P_USAGE_COUNT, UPDATED_AT = NOW(
    ), METADATA = COALESCE(
        P_METADATA,
        GUEST_USAGE_TRACKING.METADATA
    ) RETURNING USAGE_COUNT INTO V_NEW_USAGE_COUNT;
    RETURN V_NEW_USAGE_COUNT;
END;

$$     LANGUAGE PLPGSQL;
 
-- Function to get guest usage
CREATE OR REPLACE

FUNCTION GET_GUEST_USAGE(
    P_CLIENT_IP VARCHAR(45),
    P_MACHINE_FINGERPRINT VARCHAR(32),
    P_SERVICE_NAME VARCHAR(50),
    P_FEATURE_NAME VARCHAR(100),
    P_RESET_PERIOD VARCHAR(20) DEFAULT 'daily'
) RETURNS INTEGER AS
    $$           DECLARE V_USAGE_COUNT INTEGER := 0;
    V_START_DATE DATE;
BEGIN
 
    -- Calculate start date based on reset period
    CASE P_RESET_PERIOD
        WHEN 'hourly' THEN
            V_START_DATE := CURRENT_DATE;
        WHEN 'daily' THEN
            V_START_DATE := CURRENT_DATE;
        WHEN 'weekly' THEN
            V_START_DATE := CURRENT_DATE - INTERVAL '7 days';
        WHEN 'monthly' THEN
            V_START_DATE := CURRENT_DATE - INTERVAL '30 days';
        ELSE
            V_START_DATE := CURRENT_DATE;
    END CASE;

    SELECT
        COALESCE(SUM(GUT.USAGE_COUNT),
        0) INTO V_USAGE_COUNT
    FROM
        GUEST_USAGE_TRACKING GUT
    WHERE
        GUT.CLIENT_IP = P_CLIENT_IP
        AND (P_MACHINE_FINGERPRINT IS NULL
        OR GUT.MACHINE_FINGERPRINT = P_MACHINE_FINGERPRINT)
        AND GUT.SERVICE_NAME = P_SERVICE_NAME
        AND GUT.FEATURE_NAME = P_FEATURE_NAME
        AND GUT.USAGE_DATE >= V_START_DATE;
    RETURN V_USAGE_COUNT;
END;

$$     LANGUAGE PLPGSQL STABLE;
 
-- ================================
-- CREATE TRIGGERS
-- ================================
-- Update triggers for timestamp management
CREATE OR REPLACE

FUNCTION UPDATE_UPDATED_AT_COLUMN(
) RETURNS TRIGGER AS
    $$     BEGIN NEW.UPDATED_AT = NOW();
    RETURN NEW;
END;
$$     LANGUAGE PLPGSQL;
 
-- Apply triggers to tables
DO     $$ BEGIN IF NOT EXISTS (
    SELECT
        1
    FROM
        PG_TRIGGER
    WHERE
        TGNAME = 'update_global_guest_quotas_updated_at'
) THEN
    CREATE TRIGGER UPDATE_GLOBAL_GUEST_QUOTAS_UPDATED_AT BEFORE
    UPDATE ON GLOBAL_GUEST_QUOTAS FOR EACH ROW EXECUTE FUNCTION UPDATE_UPDATED_AT_COLUMN(
    );
END IF;

IF     NOT EXISTS (
    SELECT
        1
    FROM
        PG_TRIGGER
    WHERE
        TGNAME = 'update_guest_usage_tracking_updated_at'
) THEN
    CREATE TRIGGER UPDATE_GUEST_USAGE_TRACKING_UPDATED_AT BEFORE UPDATE ON GUEST_USAGE_TRACKING FOR EACH ROW EXECUTE

    FUNCTION UPDATE_UPDATED_AT_COLUMN(
    );
END IF;
IF     NOT EXISTS (
    SELECT
        1
    FROM
        PG_TRIGGER
    WHERE
        TGNAME = 'update_user_quota_overrides_updated_at'
) THEN
    CREATE TRIGGER UPDATE_USER_QUOTA_OVERRIDES_UPDATED_AT BEFORE UPDATE ON USER_QUOTA_OVERRIDES FOR EACH ROW EXECUTE

    FUNCTION UPDATE_UPDATED_AT_COLUMN(
    );
END IF;
IF     NOT EXISTS (
    SELECT
        1
    FROM
        PG_TRIGGER
    WHERE
        TGNAME = 'update_custom_alerts_updated_at'
) THEN
    CREATE TRIGGER UPDATE_CUSTOM_ALERTS_UPDATED_AT BEFORE UPDATE ON CUSTOM_ALERTS FOR EACH ROW EXECUTE

    FUNCTION UPDATE_UPDATED_AT_COLUMN(
    );
END IF;
END $$;