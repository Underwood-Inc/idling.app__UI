name: Tests
on:
  push:
    branches: [main, master]
  pull_request:
    types: [opened, synchronize, reopened]

# Required permissions for GitHub Actions
permissions:
  contents: read
  actions: write
  checks: write # For test results in PR checks
  pull-requests: write # For PR comments and summaries

# Environment variables available to all jobs
env:
  AUTH_TRUST_HOST: true
  NEXTAUTH_URL: http://localhost:3000
  # Secrets are encrypted environment variables
  NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
  AUTHJS_SESSION_TOKEN: ${{ secrets.AUTHJS_SESSION_TOKEN }}
  AUTHJS_CALLBACK_URL: ${{ secrets.AUTHJS_CALLBACK_URL }}
  AUTHJS_CSRF_TOKEN: ${{ secrets.AUTHJS_CSRF_TOKEN }}
  POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
  POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_HOST_AUTH_METHOD: md5
  POSTGRES_INITDB_ARGS: --auth-host=md5
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

jobs:
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    environment: actions
    steps:
      # Checkout code with full git history for proper versioning
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Setup Node.js using LTS version
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*

      # Install project dependencies
      - name: Install dependencies
        run: npm install -g yarn && yarn

      # Cache dependencies to speed up future runs
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.cache/playwright
          key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock') }}

  playwright:
    name: Playwright Tests
    needs: setup # Waits for setup job to complete
    runs-on: ubuntu-latest
    environment: actions
    services:
      # PostgreSQL service container for E2E tests
      postgres:
        image: postgres
        env:
          # Database configuration
          POSTGRES_HOST: ${{ secrets.POSTGRES_HOST }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_HOST_AUTH_METHOD: md5
          POSTGRES_INITDB_ARGS: --auth-host=md5
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      # Standard checkout and setup steps
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*

      # Restore cached dependencies
      - name: Restore cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.cache/playwright
          key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock') }}

      # We reinstall dependencies after cache restoration because:
      # 1. Cache might be empty or outdated
      # 2. Some dependencies might need post-install scripts to run
      # 3. Ensures consistent state even if cache restore fails
      - name: Install dependencies
        run: yarn install

      # Save cache after installing dependencies
      - name: Save cache
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            ~/.cache/playwright
          key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock') }}

      # Install browser dependencies
      - name: Install Playwright Browsers
        run: npx playwright install --with-deps

      # Setup test database
      - name: Run migrations
        run: psql -v POSTGRES_DB="$POSTGRES_DB" -v POSTGRES_PASSWORD="$POSTGRES_PASSWORD" -v POSTGRES_USER="$POSTGRES_USER" -f ./src/lib/scripts/000-init.sql postgresql://${{secrets.POSTGRES_USER}}:${{secrets.POSTGRES_PASSWORD}}@${{secrets.POSTGRES_HOST}}:${{secrets.POSTGRES_PORT}}

      # Run E2E tests
      - name: Run Playwright tests
        run: |
          echo "::group::Running Playwright Tests"
          IS_CI=1 FORCE_COLOR=1 yarn playwright test --reporter=list,github
          echo "::endgroup::"

      # Always upload test results
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-results
          path: |
            playwright-report/
            test-results/
          retention-days: 30

      # Upload traces only on failure
      - name: Upload test traces on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-traces
          path: test-results/
          retention-days: 7

      # Add this shared function to both Playwright and Jest steps
      - name: Update Test Report Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { existsSync, readFileSync } = require('fs');

            async function updateTestComment(newSection) {
              try {
                // Only proceed if we're in a PR context
                if (!context.payload.pull_request) {
                  console.log('Not a pull request - skipping comment update');
                  return;
                }

                // Updated regex to be more flexible with emoji placement
                const sectionMatch = newSection.match(/## (?:[üé≠üÉè] )?(Playwright|Jest)(?: Tests)/);
                if (!sectionMatch) {
                  console.log('Section content:', newSection); // Debug log
                  throw new Error('Invalid section format: Missing or malformed header');
                }
                const sectionType = sectionMatch[1];

                // Find existing comment
                const { data: comments } = await github.rest.issues.listComments({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                const existingComment = comments.find(comment => 
                  comment.body.includes('# üöÄ Test Results')
                );
                
                let commentBody = '';
                
                if (existingComment) {
                  // If comment exists, parse existing sections
                  const sections = existingComment.body.split(/(?=## (?:[üé≠üÉè] )?(Playwright|Jest)(?: Tests))/);
                  const header = sections[0].includes('# üöÄ Test Results') 
                    ? sections.shift() 
                    : '# üöÄ Test Results\n\n';
                  
                  // Replace or add new section
                  const sectionIndex = sections.findIndex(s => s.includes(sectionType));
                  
                  if (sectionIndex >= 0) {
                    sections[sectionIndex] = newSection;
                  } else {
                    sections.push(newSection);
                  }
                  
                  commentBody = header + sections.join('');
                } else {
                  // If no comment exists, create new one
                  commentBody = '# üöÄ Test Results\n\n' + newSection;
                }
                
                if (existingComment) {
                  await github.rest.issues.updateComment({
                    comment_id: existingComment.id,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: commentBody
                  });
                } else {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: commentBody
                  });
                }
              } catch (error) {
                console.error('Error updating test report comment:', error);
                throw error;
              }
            }

            // Generate Playwright section
            if ('${{ github.job }}' === 'playwright') {
              const reportPath = 'playwright-report/results.json';
              
              if (!existsSync(reportPath)) {
                console.log('Playwright results file not found, skipping report');
                return;
              }

              const report = JSON.parse(readFileSync(reportPath, 'utf8'));
              
              const stats = report.stats;
              const failed = report.suites.filter(s => s.status === 'failed');
              
              // Updated header format to match regex
              let section = `## üé≠ Playwright Tests\n\n`;
              section += `| Status | Count |\n|--------|-------|\n`;
              section += `| ‚úÖ Passed | ${stats.passed} |\n`;
              section += `| ‚ùå Failed | ${stats.failed} |\n`;
              section += `| ‚è≠Ô∏è Skipped | ${stats.skipped} |\n`;
              section += `| ‚è±Ô∏è Duration | ${Math.round(stats.duration / 1000)}s |\n\n`;
              
              if (failed.length > 0) {
                section += `### Failed Playwright Tests\n\n`;
                failed.forEach(suite => {
                  section += `<details><summary>‚ùå ${suite.title}</summary>\n\n`;
                  section += `\`\`\`ansi\n${suite.error}\n\`\`\`\n\n</details>\n\n`;
                });
              }
              
              await updateTestComment(section);
            }

  jest:
    name: Jest Tests
    needs: setup # Waits for setup job to complete
    runs-on: ubuntu-latest
    environment: actions
    steps:
      # Standard checkout and setup steps
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: lts/*

      # Restore cached dependencies
      - name: Restore cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock') }}

      # We reinstall dependencies after cache restoration because:
      # 1. Cache might be empty or outdated
      # 2. Some dependencies might need post-install scripts to run
      # 3. Ensures consistent state even if cache restore fails
      - name: Install dependencies
        run: yarn install

      # Save cache after installing dependencies
      - name: Save cache
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock') }}

      # Run unit tests
      - name: Run Jest tests
        run: |
          echo "::group::Running Jest Tests"
          FORCE_COLOR=1 yarn test:coverage --ci --colors --json --testLocationInResults --outputFile="$GITHUB_WORKSPACE/jest-results.json"
          echo "::endgroup::"

      # Process and report test results
      - name: Process and report Jest results
        if: always()
        uses: tanmen/jest-reporter@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-file: ${{ github.workspace }}/jest-results.json

      # Upload coverage reports
      - name: Upload Jest coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jest-coverage
          path: coverage/
          retention-days: 30

      # Add this shared function to both Playwright and Jest steps
      - name: Update Test Report Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { existsSync, readFileSync } = require('fs');

            async function updateTestComment(newSection) {
              try {
                // Only proceed if we're in a PR context
                if (!context.payload.pull_request) {
                  console.log('Not a pull request - skipping comment update');
                  return;
                }

                // Updated regex to be more flexible with emoji placement
                const sectionMatch = newSection.match(/## (?:[üé≠üÉè] )?(Playwright|Jest)(?: Tests)/);
                if (!sectionMatch) {
                  console.log('Section content:', newSection); // Debug log
                  throw new Error('Invalid section format: Missing or malformed header');
                }
                const sectionType = sectionMatch[1];

                // Find existing comment
                const { data: comments } = await github.rest.issues.listComments({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                const existingComment = comments.find(comment => 
                  comment.body.includes('# üöÄ Test Results')
                );
                
                let commentBody = '';
                
                if (existingComment) {
                  // If comment exists, parse existing sections
                  const sections = existingComment.body.split(/(?=## (?:[üé≠üÉè] )?(Playwright|Jest)(?: Tests))/);
                  const header = sections[0].includes('# üöÄ Test Results') 
                    ? sections.shift() 
                    : '# üöÄ Test Results\n\n';
                  
                  // Replace or add new section
                  const sectionIndex = sections.findIndex(s => s.includes(sectionType));
                  
                  if (sectionIndex >= 0) {
                    sections[sectionIndex] = newSection;
                  } else {
                    sections.push(newSection);
                  }
                  
                  commentBody = header + sections.join('');
                } else {
                  // If no comment exists, create new one
                  commentBody = '# üöÄ Test Results\n\n' + newSection;
                }
                
                if (existingComment) {
                  await github.rest.issues.updateComment({
                    comment_id: existingComment.id,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: commentBody
                  });
                } else {
                  await github.rest.issues.createComment({
                    issue_number: context.issue.number,
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    body: commentBody
                  });
                }
              } catch (error) {
                console.error('Error updating test report comment:', error);
                throw error;
              }
            }

            // Generate Playwright section
            if ('${{ github.job }}' === 'playwright') {
              const reportPath = 'playwright-report/results.json';
              
              if (!existsSync(reportPath)) {
                console.log('Playwright results file not found, skipping report');
                return;
              }

              const report = JSON.parse(readFileSync(reportPath, 'utf8'));
              
              const stats = report.stats;
              const failed = report.suites.filter(s => s.status === 'failed');
              
              // Updated header format to match regex
              let section = `## üé≠ Playwright Tests\n\n`;
              section += `| Status | Count |\n|--------|-------|\n`;
              section += `| ‚úÖ Passed | ${stats.passed} |\n`;
              section += `| ‚ùå Failed | ${stats.failed} |\n`;
              section += `| ‚è≠Ô∏è Skipped | ${stats.skipped} |\n`;
              section += `| ‚è±Ô∏è Duration | ${Math.round(stats.duration / 1000)}s |\n\n`;
              
              if (failed.length > 0) {
                section += `### Failed Playwright Tests\n\n`;
                failed.forEach(suite => {
                  section += `<details><summary>‚ùå ${suite.title}</summary>\n\n`;
                  section += `\`\`\`ansi\n${suite.error}\n\`\`\`\n\n</details>\n\n`;
                });
              }
              
              await updateTestComment(section);
            }

            // Generate Jest section
            if ('${{ github.job }}' === 'jest') {
              const reportPath = 'jest-results.json';
              
              if (!existsSync(reportPath)) {
                console.log('Jest results file not found, skipping report');
                return;
              }

              const results = JSON.parse(readFileSync(reportPath, 'utf8'));
              
              // Updated header format to match regex
              let section = `## üÉè Jest Tests\n\n`;
              section += `| Status | Count |\n|--------|-------|\n`;
              section += `| ‚úÖ Passed | ${results.numPassedTests} |\n`;
              section += `| ‚ùå Failed | ${results.numFailedTests} |\n`;
              section += `| ‚è≠Ô∏è Skipped | ${results.numPendingTests} |\n`;
              section += `| ‚è±Ô∏è Duration | ${formattedDuration} |\n\n`;
              
              if (results.numFailedTests > 0) {
                section += `### Failed Jest Tests\n\n`;
                results.testResults.forEach(suite => {
                  if (suite.numFailingTests > 0) {
                    suite.testResults
                      ?.filter(test => test.status === 'failed')
                      .forEach(test => {
                        section += `<details><summary>‚ùå ${test.fullName || test.title}</summary>\n\n`;
                        section += `\`\`\`ansi\n${(test.failureMessages || []).join('\n')}\n\`\`\`\n\n</details>\n\n`;
                      });
                  }
                });
              }
              
              await updateTestComment(section);
            }

  sonar:
    name: SonarCloud Analysis
    needs: [playwright, jest] # Waits for both test jobs
    runs-on: ubuntu-latest
    environment: actions
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # Download test results for analysis
      - name: Download all workflow run artifacts
        uses: actions/download-artifact@v4
      # Run SonarCloud analysis
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      # Add this after SonarCloud scan
      - name: Create SonarCloud Report Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const sonarResults = process.env.SONAR_RESULTS;
              
              let comment = `## üîç SonarCloud Analysis Results\n\n`;
              comment += `| Metric | Value |\n|--------|-------|\n`;
              comment += `| üêõ Bugs | ${sonarResults.bugs || 0} |\n`;
              comment += `| üîí Vulnerabilities | ${sonarResults.vulnerabilities || 0} |\n`;
              comment += `| üßπ Code Smells | ${sonarResults.code_smells || 0} |\n`;
              comment += `| üìä Coverage | ${sonarResults.coverage || '0'}% |\n`;
              
              if (sonarResults.issues?.length > 0) {
                comment += `\n### Issues Found\n\n`;
                sonarResults.issues.forEach(issue => {
                  comment += `<details><summary>${issue.severity}: ${issue.message}</summary>\n\n`;
                  comment += `- File: ${issue.component}\n`;
                  comment += `- Line: ${issue.line}\n`;
                  comment += `- Rule: ${issue.rule}\n\n</details>\n\n`;
                });
              }
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            } catch (error) {
              console.error('Error creating SonarCloud report comment:', error);
            }
